## 创建型

#### 单例设计模式（Singleton）

##### 基本概念

定义：确保一个类只有一个实例，并提供一个全局访问点

单例模式的三个要素：1、此类只能有一个实例 2、此类必须自行创建这个实例 3、必须自行向整个系统提供这个实例

优点：可以严格控制怎样和何时访问它；由于系统内存中只存在一个对象，因此可以节约系统资源，提高性能

缺点：由于没有抽象层，因此不易扩展；单例类的职责过重，违背“单一职责原则”。

适用情况：系统只需要一个实例对象，调用类的单个实例只允许使用一个公共访问点。



## 结构型

#### 适配器模式（Adapter）

​	定义：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式即可以作为类结构型模式，也可以作为对象结构型模式。

​	模式结构

Target:目标抽象类；Adapter:适配器类；Adaptee:适配者类；Client:客户类

使用场景：系统需要复用现有类，而该类不符合系统的需求；
想要建立一个可重复使用类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。

#### 外观模式（Facade）

​	定义：外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。

​	模式结构：

Facade: 外观角色

SubSystem:子系统角色

#### 桥接模式（Bridge）

​	定义：桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式

​	模式结构：

桥接模式包含如下角色：

- Abstraction：抽象类
- RefinedAbstraction：扩充抽象类
- Implementor：实现类接口
- ConcreteImplementor：具体实现类



## 行为型

#### 策略模式（Strategy）

​	定义：策略模式是针对一组算法，将每个算法封装到具有公共接口的独立的类中，从而使它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。

策略模式包含如下角色：

- Context: 环境类
- Strategy: 抽象策略类
- ConcreteStrategy: 具体策略类

设计思想：策略模式体现两个基本的面向对象的设计思想：封装变化和面向接口编程。

#### 中介者模式（Mediator）

​	定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

中介者模式包含如下角色：

- Mediator: 抽象中介者
- ConcreteMediator: 具体中介者
- Colleague: 抽象同事类
- ConcreteColleague: 具体同事类

#### 观察者模式（Observer）

​	定义：观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。

​	模式动机：建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。

​	模式结构：

观察者模式包含如下角色：

- Subject: 目标
- ConcreteSubject: 具体目标
- Observer: 观察者
- ConcreteObserver: 具体观察者